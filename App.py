from flask import Flask, jsonify, request
from flask_cors import CORS
import sqlite3
import bcrypt
import oracledb

app = Flask(__name__)
CORS(app)


# ----------------------------
# DATABASE CONNECTIONS
# ----------------------------
def get_db_connection():
    """SQLite connection"""
    return sqlite3.connect('Finance.db', check_same_thread=False)

def get_oracle_connection():
    """Oracle connection"""
    return oracledb.connect(user="system", password="200611", dsn="localhost:1521/XE")


# ----------------------------
# REGISTER USER (SQLite + Oracle)
# ----------------------------
@app.route("/api/register", methods=["POST"])
def register_user():
    try:
        data = request.get_json()
        username = data.get("username")
        email = data.get("email")
        password = data.get("password")

        if not (username and email and password):
            return jsonify({"message": "All fields are required"}), 400

        # Hash password
        hashed_pw = bcrypt.hashpw(password.encode("utf-8"), bcrypt.gensalt())

        # ‚úÖ SQLite insert
        conn = get_db_connection()
        cursor = conn.cursor()


        cursor.execute("SELECT * FROM register WHERE email=? OR username=?", (email, username))
        if cursor.fetchone():
            conn.close()
            return jsonify({"message": "User already exists"}), 400

        cursor.execute(
            "INSERT INTO register (username, email, password) VALUES (?, ?, ?)",
            (username, email, hashed_pw)
        )
        conn.commit()
        conn.close()

        # ‚úÖ Oracle insert
        try:
            oracle_conn = get_oracle_connection()
            oracle_cur = oracle_conn.cursor()

            oracle_cur.execute("""
                BEGIN
                    EXECUTE IMMEDIATE '
                        CREATE TABLE register (
                            user_id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
                            username VARCHAR2(100) UNIQUE NOT NULL,
                            email VARCHAR2(100) UNIQUE NOT NULL,
                            password VARCHAR2(200) NOT NULL,
                            created_at DATE DEFAULT SYSDATE
                        )';
                EXCEPTION
                    WHEN OTHERS THEN
                        IF SQLCODE != -955 THEN
                            RAISE;
                        END IF;
                END;
            """)

            oracle_cur.execute("""
                INSERT INTO register (username, email, password)
                VALUES (:1, :2, :3)
            """, (username, email, hashed_pw.decode("utf-8")))
            oracle_conn.commit()
            oracle_conn.close()

        except Exception as e:
            print("‚ö†Ô∏è Oracle insert failed:", e)

        return jsonify({"message": "‚úÖ Registration successful (saved in both DBs)!"}), 201

    except Exception as e:
        print("Error in registration:", e)
        return jsonify({"message": "Server error", "error": str(e)}), 500


# ----------------------------
# LOGIN USER (Checks both DBs)
# ----------------------------
@app.route("/api/login", methods=["POST"])
def login_user():
    try:
        data = request.get_json()
        email = data.get("email")
        password = data.get("password")

        if not (email and password):
            return jsonify({"message": "Email and password are required"}), 400

        # üîπ 1. Try SQLite first
        conn = get_db_connection()
        cursor = conn.cursor()
        cursor.execute("SELECT user_id, password, username FROM register WHERE email=?", (email,))
        user = cursor.fetchone()
        conn.close()

        if user:
            user_id, hashed_pw, username = user
            if bcrypt.checkpw(password.encode("utf-8"), hashed_pw):
                return jsonify({
                    "message": f"‚úÖ Welcome back, {username}!",
                    "user_id": user_id,
                    "username": username
                }), 200
            else:
                return jsonify({"message": "Invalid password"}), 401

        # üîπ 2. If not found, check Oracle
        try:
            oracle_conn = get_oracle_connection()
            oracle_cur = oracle_conn.cursor()
            oracle_cur.execute("SELECT user_id, username, password FROM register WHERE email = :1", [email])
            oracle_user = oracle_cur.fetchone()
            oracle_conn.close()

            if oracle_user:
                user_id, username, hashed_pw = oracle_user
                if bcrypt.checkpw(password.encode("utf-8"), hashed_pw.encode("utf-8")):
                    return jsonify({
                        "message": f"‚úÖ Welcome back, {username}!",
                        "user_id": user_id,
                        "username": username
                    }), 200
                else:
                    return jsonify({"message": "Invalid password"}), 401

        except Exception as e:
            print("‚ö†Ô∏è Oracle login check failed:", e)

        # üîπ If not found anywhere
        return jsonify({"message": "Invalid email or user not found"}), 404

    except Exception as e:
        print("Error in login:", e)
        return jsonify({"message": "Server error", "error": str(e)}), 500

# ----------------------------
# ADD INCOME (SQLite + Oracle)
# ----------------------------
@app.route("/api/income", methods=["POST"])
def add_income():
    try:
        data = request.get_json()
        user_id = data.get("user_id")
        month = data.get("month")
        source = data.get("source")
        amount = data.get("amount")
        date_received = data.get("date_received")
        notes = data.get("notes")

        
        if not user_id or not source or not amount or not date_received:
            print("‚ö†Ô∏è Missing required fields:", data)
            return jsonify({"message": "User ID, Source, Amount, and Date are required"}), 400

        # Normalize date (remove time part if exists)
        if "T" in date_received:
            date_received = date_received.split("T")[0]

        # ---------- SQLite ----------
        sqlite_conn = get_db_connection()
        sqlite_cur = sqlite_conn.cursor()

        sqlite_cur.execute("""
            CREATE TABLE IF NOT EXISTS monthly_income (
                income_id INTEGER PRIMARY KEY AUTOINCREMENT,
                user_id INTEGER,
                month TEXT,
                source TEXT,
                amount REAL,
                date_received TEXT,
                notes TEXT
            )
        """)

        sqlite_cur.execute("""
            INSERT INTO monthly_income (user_id, month, source, amount, date_received, notes)
            VALUES (?, ?, ?, ?, ?, ?)
        """, (user_id, month, source, amount, date_received, notes))

        sqlite_conn.commit()
        sqlite_conn.close()

        # ---------- Oracle ----------
        try:
            oracle_conn = get_oracle_connection()
            oracle_cur = oracle_conn.cursor()

            # Create table if not exists (ignore ORA-00955)
            oracle_cur.execute("""
                BEGIN
                    EXECUTE IMMEDIATE '
                        CREATE TABLE monthly_income (
                            income_id NUMBER GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
                            user_id NUMBER,
                            month VARCHAR2(50),
                            source VARCHAR2(100),
                            amount NUMBER(12,2),
                            date_received DATE,
                            notes VARCHAR2(255)
                        )';
                EXCEPTION
                    WHEN OTHERS THEN
                        IF SQLCODE != -955 THEN
                            RAISE;
                        END IF;
                END;
            """)

            oracle_cur.execute("""
                INSERT INTO monthly_income (user_id, month, source, amount, date_received, notes)
                VALUES (:1, :2, :3, :4, TO_DATE(:5, 'YYYY-MM-DD'), :6)
            """, (user_id, month, source, amount, date_received, notes))

            oracle_conn.commit()
            oracle_conn.close()

        except Exception as e:
            print("‚ö†Ô∏è Oracle income insert failed:", e)

        return jsonify({"message": "‚úÖ Income added successfully!"}), 201

    except Exception as e:
        print("‚ùå Error adding income:", e)
        return jsonify({"message": "Server error", "error": str(e)}), 500

# ----------------------------
# VIEW INCOME BY USER (SQLite + Oracle) 
# ----------------------------
@app.route("/api/income/<int:user_id>", methods=["GET"])
def view_income(user_id):
    try:
        combined_income = {}
        
        # ---------- SQLite ----------
        sqlite_conn = get_db_connection()
        sqlite_cur = sqlite_conn.cursor()
        sqlite_cur.execute("""
            SELECT income_id, month, source, amount, date_received, notes
            FROM monthly_income
            WHERE user_id=? ORDER BY income_id DESC
        """, (user_id,))
        for r in sqlite_cur.fetchall():
            key = (r[1], r[2], r[3], r[4]) 
            combined_income[key] = {
                "income_id": r[0],
                "month": r[1],
                "source": r[2],
                "amount": r[3],
                "date_received": r[4],
                "notes": r[5],
                "source_db": "SQLite"
            }
        sqlite_conn.close()

        # ---------- Oracle ----------
        try:
            oracle_conn = get_oracle_connection()
            oracle_cur = oracle_conn.cursor()
            oracle_cur.execute("""
                SELECT income_id, month, source, amount, TO_CHAR(date_received,'YYYY-MM-DD'), notes
                FROM monthly_income
                WHERE user_id=:1 ORDER BY income_id DESC
            """, [user_id])
            for r in oracle_cur.fetchall():
                key = (r[1], r[2], r[3], r[4])
                if key not in combined_income:
                    combined_income[key] = {
                        "income_id": r[0],
                        "month": r[1],
                        "source": r[2],
                        "amount": r[3],
                        "date_received": r[4],
                        "notes": r[5],
                        "source_db": "Oracle"
                    }
            oracle_conn.close()
        except Exception as e:
            print("‚ö†Ô∏è Oracle fetch income failed:", e)

        # Convert to list sorted by date_received descending
        result = sorted(combined_income.values(), key=lambda x: x['date_received'], reverse=True)
        return jsonify(result)

    except Exception as e:
        print("Error fetching income:", e)
        return jsonify({"message": "Server error", "error": str(e)}), 500
    
# ----------------------------
# UPDATE INCOME (SQLite + Oracle)
# ----------------------------
@app.route("/api/income/<int:income_id>", methods=["PUT"])
def update_income(income_id):
    try:
        data = request.get_json()
        user_id = data.get("user_id")
        month = data.get("month")
        source = data.get("source")
        amount = data.get("amount")
        date_received = data.get("date_received")
        notes = data.get("notes")

        if not (user_id and source and amount and date_received):
            return jsonify({"message": "User ID, Source, Amount, and Date are required"}), 400

        # Normalize date (remove "T" if it exists)
        if "T" in date_received:
            date_received = date_received.split("T")[0]

        # ---------- SQLite ----------
        try:
            sqlite_conn = get_db_connection()
            sqlite_cur = sqlite_conn.cursor()
            sqlite_cur.execute("""
                UPDATE monthly_income
                SET month=?, source=?, amount=?, date_received=?, notes=?
                WHERE income_id=?
            """, (month, source, amount, date_received, notes, income_id))

            if sqlite_cur.rowcount == 0:
                # If record not found, insert new
                sqlite_cur.execute("""
                    INSERT INTO monthly_income (income_id, user_id, month, source, amount, date_received, notes)
                    VALUES (?, ?, ?, ?, ?, ?, ?)
                """, (income_id, user_id, month, source, amount, date_received, notes))

            sqlite_conn.commit()
            sqlite_conn.close()
        except Exception as e:
            print("‚ö†Ô∏è SQLite update failed:", e)

        # ---------- Oracle ----------
        try:
            oracle_conn = get_oracle_connection()
            oracle_cur = oracle_conn.cursor()

            # Try updating first ‚Äî if no rows affected, then insert
            oracle_cur.execute("""
                UPDATE monthly_income
                SET month=:1, source=:2, amount=:3,
                    date_received=TO_DATE(:4, 'YYYY-MM-DD'), notes=:5
                WHERE income_id=:6 AND user_id=:7
            """, (month, source, amount, date_received, notes, income_id, user_id))

            if oracle_cur.rowcount == 0:
                # Only insert if no record was updated
                oracle_cur.execute("""
                    INSERT INTO monthly_income (income_id, user_id, month, source, amount, date_received, notes)
                    VALUES (:1, :2, :3, :4, :5, TO_DATE(:6, 'YYYY-MM-DD'), :7)
                """, (income_id, user_id, month, source, amount, date_received, notes))

            oracle_conn.commit()
            oracle_conn.close()
        except Exception as e:
            print("‚ö†Ô∏è Oracle update failed:", e)

        return jsonify({"message": "‚úÖ Income updated successfully in both databases!"})

    except Exception as e:
        print("‚ùå Error updating income:", e)
        return jsonify({"message": "Server error", "error": str(e)}), 500

# ----------------------------
# DELETE INCOME (SQLite + Oracle)
# ----------------------------
@app.route("/api/income/<int:income_id>", methods=["DELETE"])
def delete_income(income_id):
    try:
        # ---------- SQLite ----------
        try:
            sqlite_conn = get_db_connection()
            sqlite_cur = sqlite_conn.cursor()
            sqlite_cur.execute("DELETE FROM monthly_income WHERE income_id=?", (income_id,))
            sqlite_conn.commit()
            sqlite_conn.close()
        except Exception as e:
            print("‚ö†Ô∏è SQLite delete failed:", e)

        # ---------- Oracle ----------
        try:
            oracle_conn = get_oracle_connection()
            oracle_cur = oracle_conn.cursor()
            oracle_cur.execute("DELETE FROM monthly_income WHERE income_id=:1", [income_id])
            oracle_conn.commit()
            oracle_conn.close()
        except Exception as e:
            print("‚ö†Ô∏è Oracle delete failed:", e)

        return jsonify({"message": "‚úÖ Income deleted successfully!"})

    except Exception as e:
        print("‚ùå Error deleting income:", e)
        return jsonify({"message": "Server error", "error": str(e)}), 500


# ----------------------------
# FETCH SAVINGS FOR USER
# ----------------------------
@app.route("/api/savings/<int:user_id>", methods=["GET"])
def get_savings(user_id):
    try:
        all_savings = []

        # SQLite
        try:
            sqlite_conn = get_db_connection()
            cur = sqlite_conn.cursor()
            cur.execute("SELECT * FROM savings WHERE user_id=?", (user_id,))
            rows = cur.fetchall()
            for row in rows:
                row_dict = dict(row)
                row_dict["source_db"] = "SQLite"
                all_savings.append(row_dict)
            sqlite_conn.close()
        except Exception as e:
            print("‚ö†Ô∏è SQLite fetch failed:", e)

        # Oracle
        try:
            oracle_conn = get_oracle_connection()
            cur = oracle_conn.cursor()
            cur.execute("""
                SELECT saving_id, user_id, month, amount, category, method, 
                       TO_CHAR(date_saved,'YYYY-MM-DD') as date_saved, notes
                FROM savings WHERE user_id=:1
            """, [user_id])
            rows = cur.fetchall()
            for r in rows:
                all_savings.append({
                    "saving_id": r[0],
                    "user_id": r[1],
                    "month": r[2],
                    "amount": r[3],
                    "category": r[4],
                    "method": r[5],
                    "date_saved": r[6],
                    "notes": r[7],
                    "source_db": "Oracle"
                })
            oracle_conn.close()
        except Exception as e:
            print("‚ö†Ô∏è Oracle fetch failed:", e)

        return jsonify(all_savings)
    except Exception as e:
        print("‚ùå Error fetching savings:", e)
        return jsonify({"message": "Server error", "error": str(e)}), 500

# ----------------------------
# ADD / UPDATE SAVING
# ----------------------------
@app.route("/api/savings", methods=["POST"])
@app.route("/api/savings/<int:saving_id>", methods=["PUT"])
def save_saving(saving_id=None):
    try:
        data = request.get_json()
        user_id = data.get("user_id")
        month = data.get("month")
        amount = data.get("amount")
        category = data.get("category")
        method = data.get("method")
        date_saved = data.get("date_saved")
        notes = data.get("notes", "")

        if not (user_id and month and amount and category and method and date_saved):
            return jsonify({"message": "All fields except notes are required"}), 400

        # Normalize date
        if "T" in date_saved:
            date_saved = date_saved.split("T")[0]

        # ---------- SQLite ----------
        try:
            sqlite_conn = get_db_connection()
            cur = sqlite_conn.cursor()
            if saving_id:
                # Update
                cur.execute("""
                    UPDATE savings
                    SET month=?, amount=?, category=?, method=?, date_saved=?, notes=?
                    WHERE saving_id=?
                """, (month, amount, category, method, date_saved, notes, saving_id))
            else:
                # Insert
                cur.execute("""
                    INSERT INTO savings (user_id, month, amount, category, method, date_saved, notes)
                    VALUES (?, ?, ?, ?, ?, ?, ?)
                """, (user_id, month, amount, category, method, date_saved, notes))
            sqlite_conn.commit()
            sqlite_conn.close()
        except Exception as e:
            print("‚ö†Ô∏è SQLite save failed:", e)
            return jsonify({"message": "SQLite error", "error": str(e)}), 500

        # ---------- Oracle ----------
        try:
            oracle_conn = get_oracle_connection()
            cur = oracle_conn.cursor()
            if saving_id:
                # Update
                cur.execute("""
                    UPDATE savings
                    SET month=:1, amount=:2, category=:3, method=:4,
                        date_saved=TO_DATE(:5,'YYYY-MM-DD'), notes=:6
                    WHERE saving_id=:7
                """, (month, amount, category, method, date_saved, notes, saving_id))
            else:
                # Insert (do NOT provide saving_id!)
                cur.execute("""
                    INSERT INTO savings (user_id, month, amount, category, method, date_saved, notes)
                    VALUES (:1, :2, :3, :4, :5, TO_DATE(:6,'YYYY-MM-DD'), :7)
                """, (user_id, month, amount, category, method, date_saved, notes))
            oracle_conn.commit()
            oracle_conn.close()
        except Exception as e:
            print("‚ö†Ô∏è Oracle save failed:", e)
            return jsonify({"message": "Oracle error", "error": str(e)}), 500

        msg = "Saving updated" if saving_id else "Saving added"
        return jsonify({"message": f"‚úÖ {msg} in both databases!"})

    except Exception as e:
        print("‚ùå Error saving saving:", e)
        return jsonify({"message": "Server error", "error": str(e)}), 500

# ----------------------------
# DELETE SAVING
# ----------------------------
@app.route("/api/savings/<int:saving_id>", methods=["DELETE"])
def delete_saving(saving_id):
    try:
        # SQLite
        try:
            sqlite_conn = get_db_connection()
            cur = sqlite_conn.cursor()
            cur.execute("DELETE FROM savings WHERE saving_id=?", (saving_id,))
            sqlite_conn.commit()
            sqlite_conn.close()
        except Exception as e:
            print("‚ö†Ô∏è SQLite delete failed:", e)

        # Oracle
        try:
            oracle_conn = get_oracle_connection()
            cur = oracle_conn.cursor()
            cur.execute("DELETE FROM savings WHERE saving_id=:1", [saving_id])
            oracle_conn.commit()
            oracle_conn.close()
        except Exception as e:
            print("‚ö†Ô∏è Oracle delete failed:", e)

        return jsonify({"message": "‚úÖ Saving deleted from both databases!"})

    except Exception as e:
        print("‚ùå Error deleting saving:", e)
        return jsonify({"message": "Server error", "error": str(e)}), 500




# ----------------------------
# VIEW EXPENSES BY USER (SQLite + Oracle)
# ----------------------------
@app.route("/api/expenses/<int:user_id>", methods=["GET"])
def view_expenses(user_id):
    try:
        combined_expenses = {}

        # ---------- SQLite ----------
        sqlite_conn = get_db_connection()
        sqlite_cur = sqlite_conn.cursor()
        sqlite_cur.execute("""
            SELECT expense_id, month, category, amount, date_spent, payment_method, notes
            FROM expenses
            WHERE user_id=? ORDER BY expense_id DESC
        """, (user_id,))
        for r in sqlite_cur.fetchall():
            key = (r[1], r[2], r[3], r[4])
            combined_expenses[key] = {
                "expense_id": r[0],
                "month": r[1],
                "category": r[2],
                "amount": r[3],
                "date_spent": r[4],
                "payment_method": r[5],
                "notes": r[6],
                "source_db": "SQLite"
            }
        sqlite_conn.close()

        # ---------- Oracle ----------
        try:
            oracle_conn = get_oracle_connection()
            oracle_cur = oracle_conn.cursor()
            oracle_cur.execute("""
                SELECT expense_id, month, category, amount, TO_CHAR(date_spent,'YYYY-MM-DD'), payment_method, notes
                FROM expenses
                WHERE user_id=:1 ORDER BY expense_id DESC
            """, [user_id])
            for r in oracle_cur.fetchall():
                key = (r[1], r[2], r[3], r[4])
                if key not in combined_expenses:
                    combined_expenses[key] = {
                        "expense_id": r[0],
                        "month": r[1],
                        "category": r[2],
                        "amount": r[3],
                        "date_spent": r[4],
                        "payment_method": r[5],
                        "notes": r[6],
                        "source_db": "Oracle"
                    }
            oracle_conn.close()
        except Exception as e:
            print("‚ö†Ô∏è Oracle fetch expenses failed:", e)

        result = sorted(combined_expenses.values(), key=lambda x: x['date_spent'], reverse=True)
        return jsonify(result)

    except Exception as e:
        print("‚ùå Error fetching expenses:", e)
        return jsonify({"message": "Server error", "error": str(e)}), 500
    
# ----------------------------
# ADD / UPDATE EXPENSE (SQLite + Oracle)
# ----------------------------
@app.route("/api/expenses", methods=["POST"])
@app.route("/api/expenses/<int:expense_id>", methods=["PUT"])
def save_expense(expense_id=None):
    try:
        data = request.get_json()
        user_id = data.get("user_id")
        month = (data.get("month") or "").strip()
        category = (data.get("category") or "").strip()
        amount = data.get("amount")
        date_spent = (data.get("date_spent") or "").strip()
        payment_method = (data.get("payment_method") or "").strip()
        notes = data.get("notes", "")

        if user_id is None or month == "" or category == "" \
           or amount in [None, ""] or date_spent == "" or payment_method == "":
            return jsonify({"message": "‚ö†Ô∏è Please fill all required fields"}), 400

        try:
            amount = float(amount)
        except:
            return jsonify({"message": "‚ö†Ô∏è Amount must be a number"}), 400

        if "T" in date_spent:
            date_spent = date_spent.split("T")[0]

        # ---------- SQLite ----------
        sqlite_conn = get_db_connection()
        cur = sqlite_conn.cursor()
        if expense_id:
            cur.execute("""
                UPDATE expenses
                SET month=?, category=?, amount=?, date_spent=?, payment_method=?, notes=?
                WHERE expense_id=?
            """, (month, category, amount, date_spent, payment_method, notes, expense_id))
        else:
            cur.execute("""
                INSERT INTO expenses (user_id, month, category, amount, date_spent, payment_method, notes)
                VALUES (?, ?, ?, ?, ?, ?, ?)
            """, (user_id, month, category, amount, date_spent, payment_method, notes))
            # get last SQLite expense_id
            expense_id = cur.lastrowid
        sqlite_conn.commit()
        sqlite_conn.close()

        # ---------- Oracle ----------
        try:
            oracle_conn = get_oracle_connection()
            cur = oracle_conn.cursor()

            # Use composite key: user_id + month + category + date_spent
            cur.execute("""
                SELECT expense_id FROM expenses
                WHERE user_id=:1 AND month=:2 AND category=:3 AND date_spent=TO_DATE(:4,'YYYY-MM-DD')
            """, (user_id, month, category, date_spent))
            row = cur.fetchone()

            if row:
                # Update existing Oracle expense
                oracle_expense_id = row[0]
                cur.execute("""
                    UPDATE expenses
                    SET amount=:1, payment_method=:2, notes=:3
                    WHERE expense_id=:4
                """, (amount, payment_method, notes, oracle_expense_id))
            else:
                # Insert new Oracle expense
                cur.execute("""
                    INSERT INTO expenses (user_id, month, category, amount, date_spent, payment_method, notes)
                    VALUES (:1, :2, :3, :4, TO_DATE(:5,'YYYY-MM-DD'), :6, :7)
                """, (user_id, month, category, amount, date_spent, payment_method, notes))

            oracle_conn.commit()
            oracle_conn.close()
        except Exception as e:
            print("‚ö†Ô∏è Oracle save failed:", e)

        msg = "Expense updated" if expense_id else "Expense added"
        return jsonify({"message": f"‚úÖ {msg} successfully in both databases!"})

    except Exception as e:
        print("‚ùå Error saving expense:", e)
        return jsonify({"message": "Server error", "error": str(e)}), 500


    
# ----------------------------
# DELETE EXPENSE (SQLite + Oracle)
# ----------------------------
@app.route("/api/expenses/<int:expense_id>", methods=["DELETE"])
def delete_expense(expense_id):
    try:
        # ---------- SQLite ----------
        try:
            sqlite_conn = get_db_connection()
            sqlite_cur = sqlite_conn.cursor()
            
            # First, fetch the SQLite row details
            sqlite_cur.execute("SELECT user_id, month, category, date_spent FROM expenses WHERE expense_id=?", (expense_id,))
            row = sqlite_cur.fetchone()
            if not row:
                return jsonify({"message": "‚ö†Ô∏è Expense not found"}), 404
            
            user_id, month, category, date_spent = row
            sqlite_cur.execute("DELETE FROM expenses WHERE expense_id=?", (expense_id,))
            sqlite_conn.commit()
            sqlite_conn.close()
        except Exception as e:
            print("‚ö†Ô∏è SQLite delete failed:", e)

        # ---------- Oracle ----------
        try:
            oracle_conn = get_oracle_connection()
            oracle_cur = oracle_conn.cursor()
            
            # Delete Oracle row using composite key
            oracle_cur.execute("""
                DELETE FROM expenses 
                WHERE user_id=:1 AND month=:2 AND category=:3 AND date_spent=TO_DATE(:4,'YYYY-MM-DD')
            """, (user_id, month, category, date_spent))
            
            oracle_conn.commit()
            oracle_conn.close()
        except Exception as e:
            print("‚ö†Ô∏è Oracle delete failed:", e)

        return jsonify({"message": "‚úÖ Expense deleted successfully from both databases!"})

    except Exception as e:
        print("‚ùå Error deleting expense:", e)
        return jsonify({"message": "Server error", "error": str(e)}), 500

# ----------------------------
# ADD / UPDATE BUDGET (SQLite + Oracle)
# ----------------------------
@app.route("/api/budget", methods=["POST"])
@app.route("/api/budget/<int:budget_id>", methods=["PUT"])
def save_budget(budget_id=None):
    try:
        data = request.get_json()
        user_id = data.get("user_id")
        month = (data.get("month") or "").strip()
        category = (data.get("category") or "").strip()
        planned_amount = data.get("planned_amount")
        actual_amount = data.get("actual_amount", 0)
        notes = data.get("notes", "")

        # Validate required fields
        if user_id is None or month == "" or category == "" or planned_amount in [None, ""]:
            return jsonify({"message": "‚ö† Please fill all required fields"}), 400

        try:
            planned_amount = float(planned_amount)
            actual_amount = float(actual_amount)
        except:
            return jsonify({"message": "‚ö† Amounts must be numbers"}), 400

        # ---------- SQLite ----------
        sqlite_conn = get_db_connection()
        cur = sqlite_conn.cursor()
        if budget_id:
            cur.execute("""
                UPDATE budget
                SET month=?, category=?, planned_amount=?, actual_amount=?, notes=?
                WHERE budget_id=?
            """, (month, category, planned_amount, actual_amount, notes, budget_id))
        else:
            cur.execute("""
                INSERT INTO budget (user_id, month, category, planned_amount, actual_amount, notes)
                VALUES (?, ?, ?, ?, ?, ?)
            """, (user_id, month, category, planned_amount, actual_amount, notes))
            budget_id = cur.lastrowid
        sqlite_conn.commit()
        sqlite_conn.close()

        # ---------- Oracle ----------
        try:
            oracle_conn = get_oracle_connection()
            cur = oracle_conn.cursor()

            # Use composite key to find existing budget
            cur.execute("""
                SELECT budget_id FROM budget
                WHERE user_id=:1 AND month=:2 AND category=:3
            """, (user_id, month, category))
            row = cur.fetchone()

            if row:
                # Update existing Oracle budget
                oracle_budget_id = row[0]
                cur.execute("""
                    UPDATE budget
                    SET planned_amount=:1, actual_amount=:2, notes=:3
                    WHERE budget_id=:4
                """, (planned_amount, actual_amount, notes, oracle_budget_id))
            else:
                # Insert new Oracle budget
                cur.execute("""
                    INSERT INTO budget (user_id, month, category, planned_amount, actual_amount, notes)
                    VALUES (:1, :2, :3, :4, :5, :6)
                """, (user_id, month, category, planned_amount, actual_amount, notes))

            oracle_conn.commit()
            oracle_conn.close()
        except Exception as e:
            print("‚ö† Oracle save failed:", e)

        msg = "Budget updated" if budget_id else "Budget added"
        return jsonify({"message": f"‚úÖ {msg} successfully in both databases!"})

    except Exception as e:
        print("‚ùå Error saving budget:", e)
        return jsonify({"message": "Server error", "error": str(e)}), 500

# ----------------------------
# VIEW BUDGET BY USER
# ----------------------------
@app.route("/api/budget/<int:user_id>", methods=["GET"])
def view_budget(user_id):
    try:
        combined_budgets = []
        seen_ids = set()  

        # ---------- SQLite ----------
        sqlite_conn = get_db_connection()
        sqlite_cur = sqlite_conn.cursor()
        sqlite_cur.execute('''
            SELECT budget_id, month, category, planned_amount, actual_amount, notes
            FROM budget WHERE user_id=? ORDER BY budget_id DESC
        ''', (user_id,))
        rows = sqlite_cur.fetchall()
        sqlite_conn.close()

        for r in rows:
            combined_budgets.append({
                "budget_id": r[0],
                "month": r[1],
                "category": r[2],
                "planned_amount": r[3],
                "actual_amount": r[4],
                "notes": r[5],
                "source": "SQLite"
            })
            seen_ids.add(r[0])

        # ---------- Oracle (only if not in SQLite) ----------
        try:
            oracle_conn = get_oracle_connection()
            oracle_cur = oracle_conn.cursor()
            oracle_cur.execute('''
                SELECT budget_id, month, category, planned_amount, actual_amount, notes
                FROM budget WHERE user_id = :1 ORDER BY budget_id DESC
            ''', [user_id])
            rows_oracle = oracle_cur.fetchall()
            oracle_conn.close()

            for r in rows_oracle:
                if r[0] not in seen_ids:  
                    combined_budgets.append({
                        "budget_id": r[0],
                        "month": r[1],
                        "category": r[2],
                        "planned_amount": r[3],
                        "actual_amount": r[4],
                        "notes": r[5],
                        "source": "Oracle"
                    })
        except Exception as e:
            print("‚ö† Oracle fetch budget failed:", e)

        return jsonify(combined_budgets)
    except Exception as e:
        print("Error fetching budget:", e)
        return jsonify({"message": "Server error", "error": str(e)}), 500
    
# ----------------------------
# DELETE BUDGET (SQLite + Oracle)
# ----------------------------
@app.route("/api/budget/<int:budget_id>", methods=["DELETE"])
def delete_budget(budget_id):
    try:
        # ---------- SQLite ----------
        try:
            sqlite_conn = get_db_connection()
            sqlite_cur = sqlite_conn.cursor()
            sqlite_cur.execute("SELECT user_id, month, category FROM budget WHERE budget_id=?", (budget_id,))
            row = sqlite_cur.fetchone()
            if not row:
                return jsonify({"message": "‚ö† Budget not found"}), 404
            user_id, month, category = row
            sqlite_cur.execute("DELETE FROM budget WHERE budget_id=?", (budget_id,))
            sqlite_conn.commit()
            sqlite_conn.close()
        except Exception as e:
            print("‚ö† SQLite delete failed:", e)

        # ---------- Oracle ----------
        try:
            oracle_conn = get_oracle_connection()
            oracle_cur = oracle_conn.cursor()
            oracle_cur.execute("""
                DELETE FROM budget
                WHERE user_id=:1 AND month=:2 AND category=:3
            """, (user_id, month, category))
            oracle_conn.commit()
            oracle_conn.close()
        except Exception as e:
            print("‚ö† Oracle delete failed:", e)

        return jsonify({"message": "‚úÖ Budget deleted successfully from both databases!"})

    except Exception as e:
        print("‚ùå Error deleting budget:", e)
        return jsonify({"message": "Server error", "error": str(e)}), 500
# ----------------------------
# ADD / UPDATE FINANCIAL GOALS (SQLite + Oracle)
# ----------------------------
@app.route("/api/goals", methods=["POST"])
@app.route("/api/goals/<int:goal_id>", methods=["PUT"])
def save_financial_goal(goal_id=None):
    try:
        data = request.get_json()
        user_id = data.get("user_id")
        goal_name = (data.get("goal_name") or "").strip()
        target_amount = data.get("target_amount")
        current_amount = data.get("current_amount", 0)
        target_date = (data.get("target_date") or "").strip()
        notes = (data.get("notes") or "").strip()

        # ---------- VALIDATION ----------
        if user_id is None or goal_name == "" or target_amount in [None, ""] or target_date == "":
            return jsonify({"message": "‚ö† Please fill all required fields"}), 400

        try:
            target_amount = float(target_amount)
            current_amount = float(current_amount)
        except:
            return jsonify({"message": "‚ö† Amounts must be numeric"}), 400

        # ---------- SQLITE ----------
        sqlite_conn = get_db_connection()
        cur = sqlite_conn.cursor()

        if goal_id:
            cur.execute("""
                UPDATE financial_goals
                SET goal_name=?, target_amount=?, current_amount=?, target_date=?, notes=?
                WHERE goal_id=?
            """, (goal_name, target_amount, current_amount, target_date, notes, goal_id))
        else:
            cur.execute("""
                INSERT INTO financial_goals (user_id, goal_name, target_amount, current_amount, target_date, notes)
                VALUES (?, ?, ?, ?, ?, ?)
            """, (user_id, goal_name, target_amount, current_amount, target_date, notes))
            goal_id = cur.lastrowid

        sqlite_conn.commit()
        sqlite_conn.close()

        # ---------- ORACLE ----------
        try:
            oracle_conn = get_oracle_connection()
            cur = oracle_conn.cursor()

            
            cur.execute("""
                SELECT goal_id FROM financial_goals
                WHERE user_id=:1 AND goal_name=:2 AND target_date=TO_DATE(:3, 'YYYY-MM-DD')
            """, (user_id, goal_name, target_date))
            row = cur.fetchone()

            if row:
                oracle_goal_id = row[0]
                cur.execute("""
                    UPDATE financial_goals
                    SET target_amount=:1, current_amount=:2, notes=:3
                    WHERE goal_id=:4
                """, (target_amount, current_amount, notes, oracle_goal_id))
            else:
                cur.execute("""
                    INSERT INTO financial_goals (user_id, goal_name, target_amount, current_amount, target_date, notes)
                    VALUES (:1, :2, :3, :4, TO_DATE(:5, 'YYYY-MM-DD'), :6)
                """, (user_id, goal_name, target_amount, current_amount, target_date, notes))

            oracle_conn.commit()
            oracle_conn.close()
        except Exception as e:
            print("‚ö† Oracle save failed:", e)

        msg = "Financial goal updated" if goal_id else "Financial goal added"
        return jsonify({"message": f"‚úÖ {msg} successfully in both databases!"})

    except Exception as e:
        print("‚ùå Error saving financial goal:", e)
        return jsonify({"message": "Server error", "error": str(e)}), 500


# ----------------------------
# VIEW FINANCIAL GOALS BY USER (Fixed Duplicate Issue)
# ----------------------------
@app.route("/api/goals/<int:user_id>", methods=["GET"])
def view_goals(user_id):
    try:
        combined_goals = []
        seen_keys = set()  

        # ---------- SQLite ----------
        sqlite_conn = get_db_connection()
        sqlite_cur = sqlite_conn.cursor()
        sqlite_cur.execute('''
            SELECT goal_id, goal_name, target_amount, current_amount, target_date, notes
            FROM financial_goals WHERE user_id=? ORDER BY goal_id DESC
        ''', (user_id,))
        rows = sqlite_cur.fetchall()
        sqlite_conn.close()

        for r in rows:
            key = (user_id, r[1].strip().lower(), str(r[4]))
            if key not in seen_keys:
                combined_goals.append({
                    "goal_id": r[0],
                    "goal_name": r[1],
                    "target_amount": r[2],
                    "current_amount": r[3],
                    "target_date": r[4],
                    "notes": r[5],
                    "source": "SQLite"
                })
                seen_keys.add(key)

        # ---------- Oracle ----------
        try:
            oracle_conn = get_oracle_connection()
            oracle_cur = oracle_conn.cursor()
            oracle_cur.execute('''
                SELECT goal_id, goal_name, target_amount, current_amount,
                       TO_CHAR(target_date, 'YYYY-MM-DD'), notes
                FROM financial_goals WHERE user_id = :1 ORDER BY goal_id DESC
            ''', [user_id])
            rows_oracle = oracle_cur.fetchall()
            oracle_conn.close()

            for r in rows_oracle:
                key = (user_id, r[1].strip().lower(), str(r[4]))
                if key not in seen_keys:
                    combined_goals.append({
                        "goal_id": r[0],
                        "goal_name": r[1],
                        "target_amount": r[2],
                        "current_amount": r[3],
                        "target_date": r[4],
                        "notes": r[5],
                        "source": "Oracle"
                    })
                    seen_keys.add(key)
        except Exception as e:
            print("‚ö† Oracle fetch goals failed:", e)

        # Sort by date descending
        combined_goals.sort(key=lambda x: x["target_date"], reverse=True)

        return jsonify(combined_goals)

    except Exception as e:
        print("‚ùå Error fetching goals:", e)
        return jsonify({"message": "Server error", "error": str(e)}), 500


# ----------------------------
# DELETE FINANCIAL GOAL (SQLite + Oracle)
# ----------------------------
@app.route("/api/goals/<int:goal_id>", methods=["DELETE"])
def delete_financial_goal(goal_id):
    try:
        # ---------- SQLite ----------
        try:
            sqlite_conn = get_db_connection()
            cur = sqlite_conn.cursor()
            cur.execute("SELECT user_id, goal_name, target_date FROM financial_goals WHERE goal_id=?", (goal_id,))
            row = cur.fetchone()
            if not row:
                return jsonify({"message": "‚ö† Financial goal not found"}), 404
            user_id, goal_name, target_date = row

            cur.execute("DELETE FROM financial_goals WHERE goal_id=?", (goal_id,))
            sqlite_conn.commit()
            sqlite_conn.close()
        except Exception as e:
            print("‚ö† SQLite delete failed:", e)

        # ---------- Oracle ----------
        try:
            oracle_conn = get_oracle_connection()
            oracle_cur = oracle_conn.cursor()
            oracle_cur.execute("""
                DELETE FROM financial_goals
                WHERE user_id=:1 AND goal_name=:2 AND target_date=TO_DATE(:3, 'YYYY-MM-DD')
            """, (user_id, goal_name, target_date))
            oracle_conn.commit()
            oracle_conn.close()
        except Exception as e:
            print("‚ö† Oracle delete failed:", e)

        return jsonify({"message": "‚úÖ Financial goal deleted successfully from both databases!"})

    except Exception as e:
        print("‚ùå Error deleting financial goal:", e)
        return jsonify({"message": "Server error", "error": str(e)}), 500
    
    
# =============================
# FETCH MONTHLY REPORT (PROC)
# =============================
@app.route("/api/reports/<int:user_id>/<string:year_month>", methods=["GET"])
def get_monthly_report(user_id, year_month):
    """
    Example: /api/reports/1/2025-11
    """
    conn = get_oracle_connection()
    if conn is None:
        return jsonify({"error": "Database connection failed"}), 500

    try:
        cursor = conn.cursor()

        # Declare OUT parameters
        total_income = cursor.var(oracledb.NUMBER)
        total_expenses = cursor.var(oracledb.NUMBER)
        total_savings = cursor.var(oracledb.NUMBER)
        balance = cursor.var(oracledb.NUMBER)

        # Call the stored procedure
        cursor.callproc("get_monthly_report", [
            user_id,
            year_month,
            total_income,
            total_expenses,
            total_savings,
            balance
        ])

        data = {
            "user_id": user_id,
            "month": year_month,
            "total_income": float(total_income.getvalue() or 0),
            "total_expenses": float(total_expenses.getvalue() or 0),
            "total_savings": float(total_savings.getvalue() or 0),
            "balance": float(balance.getvalue() or 0),
        }

        cursor.close()
        conn.close()
        return jsonify(data)

    except Exception as e:
        print("‚ùå Error:", e)
        return jsonify({"error": str(e)}), 500


@app.route("/api/yearly-report/<int:user_id>/<string:year>", methods=["GET"])
def get_yearly_report(user_id, year):
    try:
        connection = get_oracle_connection()
        cursor = connection.cursor()

        total_income = cursor.var(float)
        total_expenses = cursor.var(float)
        total_savings = cursor.var(float)
        balance = cursor.var(float)

        cursor.callproc("get_yearly_report", [
            user_id, year,
            total_income,
            total_expenses,
            total_savings,
            balance
        ])

        data = {
            "year": year,
            "total_income": total_income.getvalue(),
            "total_expenses": total_expenses.getvalue(),
            "total_savings": total_savings.getvalue(),
            "balance": balance.getvalue()
        }

        cursor.close()
        connection.close()
        return jsonify(data)

    except Exception as e:
        print("Error fetching yearly report:", str(e))
        return jsonify({"error": str(e)}), 500


# ----------------------------
# üîπ BACKUP DATABASE ROUTE
# ----------------------------
@app.route("/api/backup", methods=["POST"])
def backup_data():
    try:
        # ‚úÖ Connect to Oracle using your existing function
        conn = get_oracle_connection()
        cursor = conn.cursor()

        # ‚úÖ Call your PL/SQL backup procedure
        # Make sure 'backup_finance_system' is created in Oracle
        cursor.callproc("backup_finance_system")

        conn.commit()
        cursor.close()
        conn.close()

        return jsonify({
            "status": "success",
            "message": "‚úÖ Database backup completed successfully."
        })

    except Exception as e:
        print("‚ùå Error during backup:", e)
        return jsonify({
            "status": "error",
            "message": str(e)
        }), 500

# ----------------------------
# START FLASK SERVER
# ----------------------------
if __name__ == "__main__":
    app.run(debug=True)
